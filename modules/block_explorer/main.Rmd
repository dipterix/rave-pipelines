---
title: "RAVE Block Explorer"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include = FALSE}
# This code block sets up the engine environment
# Please do not remove me
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
build_pipeline <- raveio::configure_knitr()

# For debug use, try to mimic the environment of pipeline
# Load R scripts starting with `shared-` in R/ folder
.project_path <- rstudioapi::getActiveProject()
.module_id <- "block_explorer"
lapply(
  list.files(
    file.path(.project_path, "modules", .module_id, "R"),
    pattern = "^shared-.*\\.R$",
    ignore.case = TRUE,
    full.names = TRUE
  ), 
  function(f){
    source(f, local = FALSE, chdir = TRUE)
    invisible()
  })

# Load variables in `settings.yaml` and expose them to the current environment
.settings <- raveio::load_yaml(file.path(
  .project_path, "modules", 
  .module_id, "settings.yaml"))
list2env(as.list(.settings), envir = environment())
```

## Importing data from RAVE

#### Step 1: Create `RAVE` subject's instances

Noting that all the items in the `settings.yaml` are available as variables.

```{rave load_subject, language = "R", export = "subject"}
subject <- RAVESubject$new(
  project_name = project_name, 
  subject_code = subject_code
)
subject
```

#### Step 2: Load Block Data

This code chunk always runs because it caches data internally, and only a shell (pointer to the data) is returned. We do not want to cache the shell as the data content could be deleted by the users. Instead, we want the repository to decide whether to use the cache, or to update.

```{rave parse_requested_electrode, language = "R", export = "sample_electrode"}
sample_electrode <- dipsaus::parse_svec(requested_electrode)
if(length(sample_electrode) != 1) {
  stop("Sample electrode number must have length of one")
}
```

```{rave calculate_electrodes_to_load, language = "R", export = "electrodes_to_load"}
electrodes_to_load <- sort(
  c( dipsaus::parse_svec(load_electrodes), sample_electrode )
)
```

```{rave load_repository, language = "R", export = "repository", cue = "always"}
repository <- with_future_parallel({
  prepare_subject_with_blocks(
    subject = subject,
    electrodes = load_electrodes,
    reference_name = reference_name,
    blocks = block
  )
})

```

The repository may contain more electrodes than loaded thanks to the internal cache, allowing users may be able to analyze more electrodes than requested, or to reduce the time needed to load.

```{rave extract_loaded_electrodes, language = "R", export = "electrodes_loaded", cue = "always"}
electrodes_loaded <- repository$block_data[[block]]$voltage$data$get_header("cached_electrodes")
electrodes_loaded <- sort(electrodes_loaded)

if(!isTRUE(sample_electrode %in% electrodes_loaded)) {
  stop(sprintf("Sample electrode [%s] has not been loaded successfully", paste(sample_electrode, collapse = ", ")))
}
```

```{rave single_out_voltage_data, language = "R", export = "voltage"}
voltage <- repository$block_data[[block]]$voltage
```

```{rave single_out_wavelet_data, language = "R", export = "wavelet"}
wavelet <- repository$block_data[[block]]$wavelet
```

## Generate overall plots for one electrode

There are three plots to show:

-   Overall voltage & power plot
    -   Allow to select time & frequency window from the power plot
    -   Power can be baseline-corrected by
        -   Average power of each frequency
        -   No baseline
    -   Power is to be displayed in decibel unit by default, but should be able to change to other types if baseline is enabled
-   Welch-Periodogram for the whole block

Each plot has one variation that uses a subset of analysis range, just like the "zoom-in" plot in the epoch module. The footer will be used to display summary statistics of overall vs selected range. A button is needed to sync the selected time x frequency range to a range selector (input)

The affected global inputs are:

-   Electrode selector (will change `requested_electrode`)
-   2 x Time & Frequency range selector (will be the sync target)

### Prepare sample data for voltage inspection

R may become slow if [number of time points is large]([https://dipterix.org/blog/2022/R-plot-capacity](https://dipterix.org/blog/2022/R-plot-capacity/))

Luckily, visually it makes little to no difference when plotting a million points vs. decimating the signal to 10k points and then plot.

```{rave prepare_sample_for_voltage_analysis, language = "R", export = "voltage_sample"}
sample_rate <- voltage$sample_rate
voltage_single <- subset(voltage$data, Electrode ~ Electrode == sample_electrode, drop = TRUE)
n_timepoints <- length(voltage_single)
if( n_timepoints > 10000 ) {
  decimate_rate <- ceiling(n_timepoints / 10000)
  voltage_single_decimated <- ravetools::decimate(
    x = voltage_single,
    q = decimate_rate
  )
  time <- ravetools::decimate(voltage$dnames$Time, 
                              q = decimate_rate)
} else {
  decimate_rate <- 1L
  voltage_single_decimated <- voltage_single
  time <- voltage$dnames$Time
}

voltage_sample <- list(
  origin = list(
    sample_rate = sample_rate,
    time = voltage$dnames$Time,
    data = voltage_single
  ),
  decimated = list(
    decimate_factor = decimate_rate,
    sample_rate = sample_rate / decimate_rate,
    time = time,
    data = voltage_single_decimated
  )
)
```

Plot the channel trace

```{r}
decimated <- voltage_sample$decimated
ravetools::diagnose_channel(
  decimated$data, try_compress = FALSE, 
  srate = decimated$sample_rate, which = 1
)

```

Calculate Welch-Periodogram of the entire voltage signal

```{rave calculate_Welch-Periodogram, language = "R", export = "pwelch_overall"}
data <- voltage_sample$origin$data
srate <- voltage_sample$origin$sample_rate
pwelch_overall <- ravetools::pwelch(
  x = data, fs = srate, plot = FALSE,
  window = srate * 2, noverlap = srate)
```

"P-Welch" plot example:

```{r}
plot(pwelch_overall, xlim = c(0, log10(300)))
```

### Prepare sample data for time-frequency inspection

Profiling table of plotting images in `R` . It seems the rendering time is almost linear to the number of pixels. We want to reduce the total number of pixels to 50k.

| Dimension        | Render Time (s) |
|------------------|-----------------|
| $43080\times 10$ | 1.776           |
| $4308\times 100$ | 1.491           |
| $1077\times 400$ | 1.437           |
| $2000\times 100$ | 0.657           |
| $1000\times 100$ | 0.348           |
| $500\times 100$  | 0.184           |

```{rave prepare_sample_for_time-frequency_analysis, language = "R", export = "wavelet_sample"}
sample_rate <- wavelet$sample_rate
wavelet_single <- subset(wavelet$data, Electrode ~ Electrode == sample_electrode, drop = TRUE)
n_timepoints <- ncol(wavelet_single)
n_freq <- nrow(wavelet_single)

# ravetools raises errors when number of time-points < 16
if( n_freq * n_timepoints > 50000 && n_timepoints >= 16 ) {
  decimate_factor <- ceiling(n_freq * n_timepoints / 50000)
  tidx <- seq(1, n_timepoints, by = decimate_factor)
} else {
  decimate_factor <- 1
  tidx <- seq_len(n_timepoints)
}
wavelet_decimated <- wavelet_single[, tidx, drop = FALSE]

wavelet_sample <- list(
  origin = list(
    sample_rate = sample_rate,
    dnames = wavelet$dnames[c(1, 2)],
    data = wavelet_single
  ),
  decimated = list(
    decimate_factor = decimate_factor,
    sample_rate = sample_rate / decimate_factor,
    dnames = list(
      Frequency = wavelet$dnames$Frequency,
      Time = wavelet$dnames$Time[tidx]
    ),
    data = wavelet_decimated
  )
)
```

Baseline-correct power

```{rave baseline_power, language = "R", export = "power_sample"}
power_sample <- wavelet_sample
switch (
  baseline_method,
  "Welch-Periodogram" = {
    apf <- approxfun(
      x = pwelch_overall$freq, 
      y = pwelch_overall$spec)
    bl <- apf(wavelet_sample$origin$dnames$Frequency)
  }, 
  "Block-Average" = {
    bl <- rowMeans(Mod(wavelet_sample$origin$data)^2)
  }, 
  "Block-Median" = {
    bl <- apply(Mod(wavelet_sample$origin$data)^2, 1, median)
  },
  {
    bl <- 1
  }
)

power_sample$origin$data <- Mod(wavelet_sample$origin$data)^2 / bl
power_sample$decimated$data <- Mod(wavelet_sample$decimated$data)^2 / bl

switch (
  baseline_unit,
  "Decibel" = {
    power_sample$origin$data <- 10 * log10(power_sample$origin$data)
    power_sample$decimated$data <- 10 * log10(power_sample$decimated$data)
  }, 
  "Percentage-Change" = {
    power_sample$origin$data <- 100 * power_sample$origin$data - 100
    power_sample$decimated$data <- 100 * power_sample$decimated$data - 100
  },
  {
    stop("Unsupported baseline unit")
  }
)

```

Visualize power (with baseline) data in heatmap

```{r}
data <- t(power_sample$decimated$data)
rg <- range(data)
# zlim <- max(abs(rg)) * c(-1, 1)
zlim <- sd(data) * c(-1, 1) * 4
data[data < zlim[1]] <- zlim[1]
data[data > zlim[2]] <- zlim[2]
sd <- sd(data)
pal <- c("#FFFFFF", "#FFFFFF", "#FFFFFF", "purple3", "orange")
pal <- c("#053060", "darkgreen", "#FFFFFF", "orange", "#66001F")
bias <- log(2*sd / zlim[2]) / log(0.5)
col <- c(
  rev(colorRampPalette(pal[c(3,2,1)], bias = bias)(50)),
  pal[[3]],
  colorRampPalette(pal[c(3,4,5)], bias = bias)(50)
)
layout(matrix(c(1, 2), nrow = 1), widths = c(1, lcm(2)))
par(mar = c(5.1, 4.1, 4.1, 0.1))
time <- power_sample$decimated$dnames$Time
freq <- power_sample$decimated$dnames$Frequency
image(
  x = time, y = freq, z = data, zlim = zlim,
  xlab = "Time (s)", ylab = "Frequency", 
  useRaster = FALSE, col = col,
  axes = FALSE
)
axis(1, at = pretty(time))

pretty_freq <- c(pretty(freq), max(freq))
pretty_freq[pretty_freq < min(freq)] <- min(freq)
pretty_freq[pretty_freq > max(freq)] <- max(freq)
axis(2, at = sort(unique(pretty_freq)), las = 1)
par(mar = c(5.1, 0.1, 4.1, 2))
legend_data <- seq(zlim[1], zlim[2], length.out = length(col))
image(
  y = legend_data,
  z = matrix(legend_data, nrow = 1),
  col = col,
  axes = FALSE
)
axis(side = 4, at = c(zlim, -2*sd, 2*sd, 0), labels = c(sprintf("%.0f", c(zlim, -2*sd, 2*sd)), "0"), las = 1, hadj = 0.5, tck = -0.1)
axis(side = 3, at = 0.5, labels = sprintf("[%.0f:%.0f]", rg[1], rg[2]), tick = FALSE, padj = 1)
```

## Build, Visualize, & Run

```{r build, echo=FALSE, results='hide'}
build_pipeline(make_file = "make-block_explorer.R")
```

```{r visualize, echo=FALSE}
Sys.setenv("RAVE_PIPELINE" = normalizePath("."))
try({
  raveio::pipeline_visualize()
}, silent = TRUE)
```

---
title: "RAVE Pipeline Markdown Template"
output:
  html_document: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
# This code block sets up the engine environment
# Please do not remove me
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
build_pipeline <- raveio::configure_knitr()
if(FALSE) {
  invisible(list2env(as.list(local({
    settings <- raveio::load_yaml(file.path(rstudioapi::getActiveProject(), "modules", 
                                     "electrode_localization", "settings.yaml"))
    print(names(settings))
    settings
  })), envir = environment()))
}
```


```{rave load_subject, language = "R", export = "subject"}
library(raveio)
subject <- RAVESubject$new(
  project_name = project_name, 
  subject_code = subject_code
)
print(subject)
print(subject$freesurfer_path)
```


```{rave find_CT_Nifti_files, language = "R", export = "ct_candidates"}
fs_path <- subject$freesurfer_path

# nii/nii.gz files in fs_path/../coregistration, or fs_path/coregistration
if(length(fs_path) != 1 || is.na(fs_path) || !dir.exists(fs_path)) {
  stop("Cannot find surface/volume reconstruction folder.")
}

f1 <- list.files(file.path(fs_path, "coregistration"), pattern = "nii(?:\\.gz)?$", 
                 recursive = FALSE, ignore.case = TRUE, include.dirs = FALSE,
                 full.names = FALSE, all.files = FALSE)
f2 <- list.files(file.path(fs_path, "..", "coregistration"), pattern = "nii(?:\\.gz)?$", 
                 recursive = FALSE, ignore.case = TRUE, include.dirs = FALSE,
                 full.names = FALSE, all.files = FALSE)
files <- c(f1, f2)
files[duplicated(files)] <- sprintf("%s (2)", files[duplicated(files)])

ct_candidates <- structure(files, paths = list(
  f1 = f1, f2 = f2
))
```


```{rave load_brain, language = "R", export = "brain", cue = "always"}
brain <- raveio::rave_brain(subject)
```


```{rave Loading_brain_and_CT_if_exists, language = "R", export = "ct_in_t1"}
force(subject)

has_ct <- FALSE
ct_path <- character(0L)
if(length(path_ct_in_t1)) {
  if(startsWith(path_ct_in_t1, "{")) {
    s <- strsplit(path_ct_in_t1, "/|\\\\")[[1]]
    s[[1]] <- raveio::glue(s[[1]])
    s <- do.call(file.path, as.list(s))
    ct_path <- normalizePath(s, mustWork = TRUE)
  } else {
    ct_path <- normalizePath(path_ct_in_t1, mustWork = TRUE)
  }
  has_ct <- TRUE
}


if(has_ct) {
  ct_in_t1 <- threeBrain:::read_nii2(ct_path)
} else {
  ct_in_t1 <- NA
}
```

```{rave generate_indicator, language = "R", export = "ct_exists"}
ct_exists <- isTRUE(!is.null(ct_in_t1) && is.list(ct_in_t1))
```

```{rave generate_localization_viewer, language = "R", export = "viewer", cue = "always"}

control_presets <- c("localization")
controllers <- list()
controllers[["Highlight Box"]] <- FALSE
controllers[["Overlay Coronal"]] <- TRUE
controllers[["Overlay Axial"]] <- TRUE
controllers[["Overlay Sagittal"]] <- TRUE

if(!is.null(ct_in_t1) && is.list(ct_in_t1)) {
  ct <- ct_in_t1
  ct_shift <- ct$get_center_matrix()
  ct_qform <- ct$get_qform()
  matrix_world <- brain$Torig %*% solve(brain$Norig) %*% ct_qform %*% ct_shift
  threeBrain::add_voxel_cube(brain, "CT", ct$get_data(), size = ct$get_size(), matrix_world = matrix_world)
  key <- seq(0, max(ct$get_range()))
  cmap <- threeBrain::create_colormap(gtype = "volume", dtype = "continuous", 
            key = key, value = key, color = c("white", "green", "darkgreen"))
  controllers[["Left Opacity"]] <- 0.4
  controllers[["Right Opacity"]] <- 0.4
  controllers[["Voxel Type"]] <- "CT"
  controllers[["Voxel Display"]] <- "normal"
  controllers[["Voxel Min"]] <- 3000
  controllers[["Edit Mode"]] <- "CT/volume"
  
  viewer <- brain$plot(control_presets = control_presets, voxel_colormap = cmap, 
            controllers = controllers)
} else {
  controllers[["Edit Mode"]] <- "MRI slice"
        
  controllers[["Left Opacity"]] <- 0.1
  controllers[["Right Opacity"]] <- 0.1
  viewer <- brain$plot(control_presets = control_presets, controllers = controllers)
}

# If running in interactive mode
if(interactive()) {
  print(viewer)
}

```



## Build, Visualize, & Run

Please make sure the following code block is at the end of your pipeline file. This block will build the pipeline and generate a `make-electrode_localization.R` script with your pipeline markdown file. `RAVE` will use the generated pipeline script to execute the pipeline in the dashboard application, or in massive production mode.

```{r build, echo=FALSE, results='hide'}
build_pipeline(make_file = "make-electrode_localization.R")
```


Once the pipeline script `make-electrode_localization.R` is built, you can visualize and execute the pipeline without the need of re-knit this document. Notice we use `r` block instead of `rave`. (This is because the code blocks are not part of pipeline targets.)

```{r visualize, echo=FALSE}
Sys.setenv("RAVE_PIPELINE" = normalizePath("."))
raveio::pipeline_visualize()
```







